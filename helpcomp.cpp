// helpcomp.cpp

/* ----------------------------------------------------------------------------
This program produces help files for the Digital Chroma Toolkit from source 
files contained in a single source directory. It generates resource files into 
a single resource directory to be included in the Toolkit executable itself, 
and also generates HTML files into a single HTML directory that can be browsed 
with a web browser. The HTML files mimic some of the behavior of the Toolkit's 
Help screen, including the glossary popups and the three navigation buttons at 
the bottom. In addition to individual HTML pages, a "master.html" page is 
produced that concatenates all the pages, so that word searches can be 
performed across the entire help system.

The program is invoked with three directory names on the command line, the 
source directory, the resource directory, and the HTML directory. If no fatal 
errors occur while reading the source directory, the output directories are 
deleted, recreated, and filled with the results of the compilation. Fatal 
errors write a message to stderr, warnings are written to stdout.

SOURCE FILES

The input to the help compiler consists of a number of different file types, 
distinguished by their extensions:

    html -- These are the source file for each page or popup. They are just 
    HTML fragments, one or more HTML elements with no "html", "head", or "body" 
    element around them, and no "script" elements or stylesheet references.
    
    png, jpg -- These are embedded image files.

    css -- These are stylesheets.

    js -- These are JavaScript files.

    txt -- Some of these are the HTML fragments containing the boilerplate used 
    at the beginning and end of the actual HTML output files. Others list pages 
    and popups and associate them with titles and describe the navigation 
    structure.

The base filename of a page or popup must consist of letters, digits, hyphens, 
or underscores, although trailing or consecutive underscores are disallowed. 
A leading underscore is prohibited on page names, and required on popup names, 
in order to distinguish them. This allows links to be specified more concisely 
in the source by leaving off their extensions. Also, the name "master.html" is 
illegal. The default title for a page or popup is generated by replacing 
underscores with blanks (and stripping the initial one if it is a popup), so 
the case of names is significant to the help compiler, although not to Windows.

Within these page and popup files, references to other files are written using 
a special brace-enclosed syntax that the help compiler recognizes and 
translates into the appropriate HTML. This allows the compiler to translate 
them differently in the various outputs, and to keep track of what files have 
been referenced, without having to parse the HTML. The compiler also translates 
various escape sequences, as described below.

FRAGMENT FILES

The source directory must contain four fragment files:

    master-head.txt -- the HTML prepended to the master.html file.

    master-tail.txt -- the HTML appended to the master.html file.

    page-head.txt -- the HTML prepended to each individual page .html file.

    page-tail.txt -- the HTML appended to each individual page .html file.

These may include stylesheet and script references, as well as macros that are 
replaced by the names and titles of the pages that can be navigated to, as 
described below.

STYLESHEETS

There must be a source file called "styles.css", defining styles for the 
various content elements. This is copied to the resource output directory, and 
prepended to each displayed page by the Toolkit.

The HTML head files must also reference "styles.css", by including the string 
"{styles.css}", but require additional styling, so there should typically be 
files called "page.css" and "master.css", with "{page.css}" or "{master.css}" 
as a second reference.

SCRIPTS

The HTML files require JavaScript to implement the links, popups, and 
navigation features. Typically, "page-tail.txt" contains "{page.js}", 
referencing a script that implements popups and the navigation buttons with 
fixed contents, while "master-tail.txt" contains "{master.js}", referencing a 
fancier script file that also monitors the scroll position and updates the 
navigation buttons, address bar link, and tab or window title according to what 
sub-page it is on.

IMAGE REFERENCES

Page and popup files may contain embedded images, by writing the image filename 
with a ".png" or ".jpg" extension in braces. Optionally, the filename may be 
followed by a blank and any additional HTML attributes. It is translated into 
an "img" HTML element. For instance, "{foo.png}" translates into

    <img src="foo.png">

and "{foo.png width=60}" translates into

    <img src="foo.png" width=60>

PAGE LINKS

Page and popup files may link to pages, by writing the page base filename 
(without the ".html" extension) in braces. Optionally, the name may be followed 
by a blank and specific text to be used to override the default title for the 
link. In the resource output file, it is translated into an "a" HTML element, 
so, given a page file called "Foo_bar.html" which has a default title "Foo 
bar", "{Foo_bar}" translates into

    <a href="Foo_bar">Foo bar</a>

and "{Foo_bar <i>foo bars</i>}" translates into

    <a href="Foo_bar"><i>foo bars</i></a>

In the HTML output files, however, a page link is translated into a "span" HTML 
element of class "page", so that the click can be bound to a JavaScript 
function called "page". In this case, "{Foo_bar}" translates into

    <span class="page" onclick="page('Foo_bar')">Foo bar</span>

and "{Foo_bar <i>foo bars</i>}" translates into

    <span class="page" onclick="page('Foo_bar')"><i>foo bars</i></span>

This allows the individual page files to respond differently from the 
"master.html" file, by including a different definition of the "page" function.

POPUP LINKS

Page and popup files may link to popups, by writing the base popup filename 
(without the ".html" extension), which starts with an underscore, in braces. 
Optionally, the name may be followed by a blank and specific text to be used to 
override the default title for the link. In the resource output file, it is 
translated into an "a" HTML element with a "popup" classname, so that it can be 
displayed in green instead of blue. Given a popup file called "_Foo_bar.html" 
which has a default title "Foo bar", "{_Foo_bar}" translates into

    <a class="popup" href="_Foo_bar">Foo bar</a>

and "{_Foo_bar <i>foo bars</i>}" translates into

    <a class="popup" href="_Foo_bar"><i>foo bars</i></a>

In the HTML output files, the result is the same as for page files, except for 
the "popup" classname and function name:

    <span class="popup" onclick="popup('_Foo_bar')">Foo bar</span>

    <span class="popup" onclick="popup('_Foo_bar')"><i>foo bars</i></span>

SPECIAL MACROS

Two macros should be included in pages somewhere. "{#contents}" is translated 
into a series of HTML "p" elements representing the contents, indented to 
reflect the navigation structure, with "Home" at the top. "{#popups}" is 
translated into a series of HTML "p" elements representing each letter of the 
alphabet that has popup items (plus perhaps an extra one if there are items 
whose titles don't start with letters), where each paragraph is a 
semicolon-separated list of popup titles. These are only legal in page files, 
not popup files.

Six macros are legal in head and tail fragment files, and are replaced with the 
base filenames or titles of those pages that can be linked to from the current 
page. These are "{#next-link}", "{#prev-link}", "{#up-link}", "{#next-title}", 
"{#prev-title}", and "{#up-title}". These are null strings if they don't 
exist for a particular page.

ESCAPE SEQUENCES

Within page and popup source files, the characters & and < introduce HTML 
entities or tags, and the character { instroduces a file reference. The 
characters ' and " are translated into close or open quotes depending upon 
whether or not they are preceded by whitespace, except when inside an HTML tag. 
To use these characters as-is in normal text, they must be escaped by preceding 
them with a backslash. Naturally, backslash is also escaped in the same way. A 
number of additional escapes have been added for generating other entities. The 
complete list is:

    \       &nbsp;      non-breaking space (backslash is followed by space)
    \&      &amp;       ampersand
    \+      &plusmn;    plus or minus
    \-      &ndash;     n dash
    \.      &hellip;    ellipsis
    \<      &lt;        less than
    \=      &ne;        not equal
    \>      &gt;        greater than
    \b      &bull;      bullet
    \c      &cent;      cent
    \d      &deg;       degree
    \g      &ge;        greater or equal
    \l      &le;        less or equal
    \m      &mdash;     m dash
    \n      <br>        newline
    \o      &ohm;       Greek omega
    \u      &mu;        Greek mu

CONTENTS FILE

In order to know the navigation structure of the help files, the source 
directory must contain a "contents.txt" file, that lists all, or at least most, 
of the page files, one to a line, indented (using blanks, not tabs) to indicate 
the parent/child relationships and the ordering of children. The root page 
file, which isn't listed in "contents.txt", is called "index.html", since that 
is the customary name for the top file in a tree of related pages, and "Home" 
is the default title, since that is how it is named in the Toolkit 
documentation. Unindented lines in "contents.txt" are considered to be children 
of the Home page. The indentation must be coherent, or a fatal error results.

Each line lists the base page filename, without the ".html" extension. If the 
default title for a page is inadequate, perhaps because special characters are 
required, the name may be followed by a blank and an alternative title, 
possibly using HTML. For instance, the line "Parameter_pages_1_2" would 
generate the title "Parameter pages 1 2", while "Parameter_pages_1_2 Parameter 
pages 1&amp;2" would generate the title "Parameter pages 1&2". This title 
becomes the default title, but can still be overridden in individual links.

The optional "extras.txt" file may be used to list any page files that 
shouldn't appear in the navigation tree, or popup files, that need explicit 
titles with special characters. This has the same syntax as "contents.txt" but 
with no indentation.

OTHER SOURCE FILES

Page files that don't belong in the outline, and popup files, don't need to be 
listed in either file if their auto-generated title is okay. Image files are 
not listed anywhere. However, the help compiler keeps track of which files are 
accessible through links or image references from files listed in 
"contents.txt", and warns about missing files or unreferenced existing files.

OUTPUT FILES

The resource directory is filled with compiled HTML files for each page and 
popup with ".html" extensions, copies of the image files, a copy of the 
"styles.css" file, and five JSON files:

    prev.json -- maps page names to the previous page with the same parent.

    up.json -- maps page names to their parent.

    next.json -- maps page names to the next page with the same parent.

    down.json -- maps page names to their first child.

    titles.json -- maps page names to their default titles.

The strings in these JSON files don't include file extensions. Finally, the 
resource output directory contains a "help.qrc" file that lists everything for 
the Qt resource compiler.

The HTML directory is filled with generated HTML files for each page and popup 
with ".html" extensions, the "master.html" file, copies of the image, 
stylesheet, and script files, and the four JSON files.

PROCESS

On startup, the program catalogs all the files in the source directory that 
have ".html" extensions and valid names, or ".png", ".jpg", ".css", or ".js" 
extensions. It also makes sure the "index.html", "contents.txt", "styles.css", 
and the four head and tail files exist. It also processes the "contents.txt" 
and optional "extras.txt", to find any explicit titles to override the 
auto-generated ones, but also to establish the navigation structure.

If any of the required files are missing, it aborts with an error messages. If 
"contents.txt" has invalid indentation, it aborts. If it or "extras.txt" has 
duplicate names, it ignores the duplicates and issues warnings. It also issues 
warnings for any non-existent files listed in those two files, and for unknown 
files found in the source directory.

If there are no fatal errors, it deletes and recreates the output directories, 
generates JSON files containing the navigation links and titles to both output 
directories, and then starts the actual compilation process. It begins by 
compiling the "master-head.txt" file to "master.html". The head and tail files 
are only allowed to have references to style sheet and script files, and for 
each such reference, it records that the file has been referenced if it exists, 
or warns if it doesn't.

It then compiles all the pages, beginning with "index.html", followed by all 
the pages listed in "contents.txt" in the order listed, followed by any 
remaining page files in case-insensitive lexical order of title. For each page, 
it compiles "page-head.txt" to the HTML output page, compiles the page source 
to the resource output page, the HTML output page, and "master.html", and then 
compiles "page-tail.txt" to the HTML output page. When it has compiled all the 
pages, it compiles "master-tail.txt" to "master.html".

It then compiles all the popups into both the resource and HTML output 
directories.

As it compiles pages and popups, it records which existing pages, popups, and 
images each one refers to, and warns about any references to non-existent 
files. When it is all done, it then recursively follows all these links 
beginning with "index.html", and records which files are actually referenced. 
At the end, it outputs warnings for any pages, popups, images, 
stylesheets, or scripts that weren't referenced. However, the recursive process 
doesn't follow links from popups to pages or other popups, because pages or 
other popups that are only accessible from popups should still result in 
warnings.

While compiling pages, if it encounters "{#contents}", it emits links to every 
existing page file listed in "contents.txt" in the order listed, with proper 
indentation. If it encounters "{#popups}", it emits links to every existing 
popup file in case-insensitive lexical order of title.

When compilation is complete, it copies all referenced image files to both 
output directories, "styles.css" to the resource output directory, and all 
referenced stylesheet and script files to the HTML output directory.         */

#include "stdafx.h"

// Types ----------------------------------------------------------------------

using setstr    = set<string>;

struct html {
    setstr      images;     // images referred to by this page or popup
    setstr      pages;      // other pages referred to by this page or popup
    setstr      popups;     // popups referred to by this page or popup
    unsigned    references; // REFxxx value
    string      title;      // page title

                html(): references(0) {}
                html(string const& name);
    };

struct nocase_eq {
    bool operator() (path const& a, path const& b) const;
    };

struct nocase_lt {
    bool operator() (string const& a, string const& b) const;
    };

using listintstr        = list<pair<int, string>>;
using mapstrunsigned    = map<string, unsigned, nocase_lt>;
using mapstrhtml        = map<string, html, nocase_lt>;
using liststr           = list<string>;
using mapstrstr         = map<string, string, nocase_lt>;
using cimapstrstr       = mapstrstr::const_iterator;

// Constants ------------------------------------------------------------------

uint8_t const   REFNONE     = 0;    // unreachable
uint8_t const   REFORPHAN   = 1;    // reachable only via at least one popup
uint8_t const   REFPOPUP    = 2;    // popup reachable through pages
uint8_t const   REFPAGE     = 3;    // page reachable through pages

uint8_t const   WHHTML      = 1;    // write to individual HTML output
uint8_t const   WHMASTER    = 2;    // write to master HTML output
uint8_t const   WHRES       = 4;    // write to resource output
uint8_t const   WHALL       = 7;    // write to all three outputs

// Variables ------------------------------------------------------------------

listintstr      contents;       // list of indentations and names
string          datasrc;        // source file data
path            dirhtml;        // HTML directory command line parameter
path            dirres;         // resource directory command line parameter
path            dirsrc;         // source directory command line parameter
mapstrunsigned  images;         // maps image source file names to REFxxx
unsigned        indexsrc;       // index into datasrc
int             linesrc;        // source input line number
mapstrstr       navdown;        // down page in outline
mapstrstr       navnext;        // next page in outline
mapstrstr       navprev;        // previous page in outline
mapstrstr       navup;          // up page in outline
ofstream        ofshtml;        // individual HTML output file
ofstream        ofsmaster;      // master HTML output file
ofstream        ofsqrc;         // "help.qrc" output file
ofstream        ofsres;         // resource output file
mapstrhtml      pages;          // page source files
string          page_head;      // HTML to be prepended to each page
string          page_tail;      // HTML to be appended to each page
path            pathhtml;       // individual HTML output file pathname
path            pathmaster;     // master HTML output file pathname
path            pathqrc;        // "help.qrc" pathname
path            pathres;        // resource output file pathname
path            pathsrc;        // source input file pathname
mapstrhtml      popups;         // popup source files
mapstrunsigned  scripts;        // maps script source file names to REFxxx
mapstrunsigned  stylesheets;    // maps stylesheet source file names to REFxx
mapstrstr       titles;         // titles of all pages and popups

// Forward references ---------------------------------------------------------

string          decode_escape();
bool            ends_with(string const& s, string_view e);
int             getsrc();
void            nav_lookup(mapstrstr const& m, string const& n, string& name, 
                        string& title);
void            open_ofstream(ofstream& ofs, path const& s);
string          read_text(path const& p);
void            select_source(path const& p, string const& s);
bool            valid_name(string const& name);
void            write_one(ofstream& o, path const& p, char c);
void            write_one(ofstream& o, path const& p, string const& s);
void            write_one(ofstream& o, path const& p, char const* s);
void            write_out(char c, uint8_t w = WHALL);
void            write_out(string const& s, uint8_t w = WHALL);
void            write_out(char const* s, uint8_t w = WHALL);

/* html::html(string const& name); --------------------------------------------
This auto-generates a title from the specified name.                         */

html::html(string const& name): references(REFNONE), title(name) {

    if (title[0] == '_')
        title.erase(title.begin());
    for (auto& c: title)
        if (c == '_')
            c = ' ';
    }

/* nocase_eq::operator() ------------------------------------------------------
This returns true if paths are equal without regard to case.                 */

bool nocase_eq::operator()(path const& a, path const& b) const {
    string  sa = a.string();
    string  sb = b.string();

    for (unsigned i = 0; i < sa.size() && i < sb.size(); ++i) {
        int ca = tolower(sa[i] & 0xFF);
        int cb = tolower(sb[i] & 0xFF);
        if (ca - cb)
            return ca - cb;
        }
    return sa.size() - sb.size();
    }

/* nocase_lt::operator() ------------------------------------------------------
This returns true if string a is less than b. This is case-insensitive for 
ordering, but if two strings differ only in case, this orders them according to 
the first mismatching character.                                             */

bool nocase_lt::operator()(string const& a, string const& b) const {
    int     d = 0;  // difference between first mismtaching character

    for (unsigned i = 0; i < a.size() && i < b.size(); ++i) {
        int ca = a[i] & 0xFF;
        int cb = b[i] & 0xFF;
        if (ca - cb) {
            if (!d)
                d = ca - cb;
            ca = tolower(ca);
            cb = tolower(cb);
            if (ca != cb)
                return ca < cb;
            }
        }
    if (a.size() != b.size())
        return a.size() < b.size();
    else
        return d < 0;
    }

/* compile_head_tail ----------------------------------------------------------
This compiles the source string as a head or tail fragment, and writes it to 
the output file selected by w, where n is the base filename (without ".html" 
extension) of the page the fragment is framing, or a null string if framing 
"master.html". This replaces navigation macros with strings based on n. It also 
translates references to stylesheets and scripts, if those files exist, and 
records them as having been referenced.                                      */

void compile_head_tail(string const& n, uint8_t w) {
    int         c;
    string      name, title;

    // For each character...
    while ((c = getsrc()) >= 0) {

        // If open brace encountered...
        if (c == '{') {

            // Parse everything up to close brace or newline or EOF into name.
            name.clear();
            while ((c = getsrc()) >= 0 && c != '}' && c != '\n')
                name += c;

            // If no close brace, warn.
            if (c == '\n')
                cout << "invalid reference in line " << (linesrc - 1) 
                        << " in \"" << pathsrc << "\".\n";

            // Translate nav link and title macros.
            else if (name == "#next-link"sv) {
                nav_lookup(navnext, n, name, title);
                write_out(name, w);
                }
            else if (name == "#next-title"sv) {
                nav_lookup(navnext, n, name, title);
                write_out(title, w);
                }
            else if (name == "#prev-link"sv) {
                nav_lookup(navprev, n, name, title);
                write_out(name, w);
                }
            else if (name == "#prev-title"sv) {
                nav_lookup(navprev, n, name, title);
                write_out(title, w);
                }
            else if (name == "#up-link"sv) {
                nav_lookup(navup, n, name, title);
                write_out(name, w);
                }
            else if (name == "#up-title"sv) {
                nav_lookup(navup, n, name, title);
                write_out(title, w);
                }
            else if (name == "#down-link"sv) {
                nav_lookup(navdown, n, name, title);
                write_out(name, w);
                }
            else if (name == "#down-title"sv) {
                nav_lookup(navdown, n, name, title);
                write_out(title, w);
                }

            // Translate stylesheet reference.
            else if (ends_with(name, ".css"sv)) {
                auto f = stylesheets.find(name);
                if (f == stylesheets.end())
                    cout << "non-existent stylesheet in line " << linesrc 
                            << " in \"" << pathsrc << "\".\n";
                else {
                    write_out("<link rel=\"stylesheet\" href=\"", w);
                    write_out(name, w);
                    write_out("\">", w);
                    f->second = true;
                    }
                }

            // Translate script reference.
            else if (ends_with(name, ".js"sv)) {
                auto f = scripts.find(name);
                if (f == scripts.end())
                    cout << "non-existent script in line " << linesrc 
                            << " in \"" << pathsrc << "\".\n";
                else {
                    write_out("<script src=\"", w);
                    write_out(name, w);
                    write_out("\"></script>", w);
                    f->second = true;
                    }
                }

            // Warn about anything else.
            else
                cout << "invalid reference in line " << linesrc << " in \"" 
                        << pathsrc << "\".\n";
            }

        // Otherwise, copy verbatim.
        else
            write_out(c, w);
        }
    }

/* compile_html ---------------------------------------------------------------
This compiles the current source data and writes it to the output files 
selected by w. References to other files are recorded in the appropriate 
members of h.                                                                */

void compile_html(html& h, uint8_t w) {
    int         c;              // source character
    bool        intag = false;  // true while inside <...>
    bool        inwht = true;   // true after whitespace
    char        lastc;          // last initial character in glossary
    string      name;           // name from brace-enclosed reference
    string      text;           // temporary
    string      value;          // value from brace-enclosed reference

    // For each source character...
    while ((c = getsrc()) >= 0) {

        // Convert control characters other than newline to blank, and warn.
        if (c < ' ' && c != '\n') {
            cout << "control character " << int(c) << " in line " << linesrc 
                    << " of \"" << pathsrc << "\" converted to blank.\n";
            write_out(' ', w);
            inwht = true;
            }

        // If inside <>, just copy verbatim. Otherwise...
        else if (intag) {
            if (c == '>')
                intag = false;
            write_out(c, w);
            }
        else {

            // Record whether inside <>, or after whitespace.
            if (c == '<') {
                write_out(c, w);
                intag = true;
                }
            else if (c == ' ' || c == '\n') {
                write_out(c, w);
                inwht = true;
                }

            // Decode escape sequences.
            else if (c == '\\') {
                write_out(decode_escape(), w);
                inwht = false;
                }

            // If reference found...
            else if (c == '{') {

                // Parse name and value.
                name.clear();
                value.clear();
                while ((c = getsrc()) > ' ' && c != '}')
                    name += c;
                if (!name.size())
                    cout << "invalid reference in line " << linesrc << "of \"" 
                            << pathsrc << "\".\n";
                while (c == ' ')
                    c = getsrc();
                if (c && c != '}')
                    do {
                        if (c == '\\')
                            value += decode_escape();
                        else
                            value += c;
                        c = getsrc();
                        } while (c && c != '}');
                if (c < 0) {
                    cout << "premature EOF in \"" << pathsrc << "\".\n";
                    break;
                    }
                if (!name.size())
                    continue;

                // Translate {#contents} into contents list HTML.
                if (name == "#contents" && !value.size()) {
                    if (~w & WHALL) {
                        cout << " can't include {#contents} in \"" << pathsrc 
                                << "\".\n";
                        break;
                        }
                    for (auto const& cl: contents) {
                        text = "<p class=\"s m0\" style=\"margin-left: ";
                        text += to_string(20 * cl.first);
                        text += "px\">";
                        write_out(text, w);
                        write_out("<a href=\"", w & WHRES);
                        write_out("<span class=\"page\" onclick=\"page('", 
                                w & ~WHRES);
                        write_out(cl.second, w);
                        write_out("\">", w & WHRES);
                        write_out("')\">", w & ~WHRES);
                        write_out(titles[cl.second], w);
                        write_out("</a></p>\n", w & WHRES);
                        write_out("</span></p>\n", w & ~WHRES);
                        }
                    inwht = true;
                    }

                // Translate {#popups} into popup list HTML.
                else if (name == "#popups" && !value.size()) {
                    if (~w & WHALL) {
                        cout << "can't include {#popups} in \"" << pathsrc 
                                << "\".\n";
                        break;
                        }
                    lastc = 0;
                    for (auto const& p: popups) {
                        c = toupper(p.first[1]);
                        if (!lastc) {
                            lastc = c;
                            write_out("<p>", w);
                            }
                        else if (c == lastc)
                            write_out("; ", w);
                        else {
                            lastc = c;
                            write_out("</p>\n<p>", w);
                            }
                        write_out("<a class=\"popup\" href=\"", 
                                w & WHRES);
                        write_out("<span class=\"popup\" "
                                "onclick=\"popup('", w & ~WHRES);
                        write_out(p.first, w);
                        write_out("\">", w & WHRES);
                        write_out("')\">", w & ~WHRES);
                        write_out(p.second.title, w);
                        write_out("</a>", w & WHRES);
                        write_out("</span>", w & ~WHRES);
                        }
                    write_out("</p>\n", w);
                    inwht = true;
                    }

                // If image, generate <img> element.
                else if (ends_with(name, ".png"sv) 
                        || ends_with(name, ".jpg"sv)) {
                    auto& i = images.find(name);
                    if (i == images.end())
                        cout << "reference to non-existent image in line " 
                                << linesrc << " of \"" << pathsrc << "\".\n";
                    else {
                        h.images.insert(name);
                        write_out("<img src=\"", w);
                        write_out(name, w);
                        write_out('"', w);
                        if (value.size()) {
                            write_out(' ', w);
                            write_out(value, w);
                            }
                        write_out('>', w);
                        }
                    inwht = false;
                    }

                // Otherwise, must be simple name.
                else if (!valid_name(name))
                    cout << "invalid reference in line " << linesrc << " of \"" 
                            << pathsrc << "\".\n";

                // If popup, generate <a> or <span> element.
                else if (name[0] == '_') {
                    auto& i = popups.find(name);
                    if (i == popups.end())
                        cout << "reference to non-existing popup in line " 
                                << linesrc << " of \"" << pathsrc << "\".\n";
                    else {
                        h.popups.insert(name);
                        write_out("<a class=\"popup\" href=\"", w & WHRES);
                        write_out("<span class=\"popup\" onclick=\"popup('", 
                                w & ~WHRES);
                        write_out(name, w);
                        write_out("\">", w & WHRES);
                        write_out("')\">", w & ~WHRES);
                        write_out(value.size() ? value : i->second.title, w);
                        write_out("</a>", w & WHRES);
                        write_out("</span>", w & ~WHRES);
                        }
                    inwht = false;
                    }

                // If page, generate <a> or <span> element.
                else {
                    auto& i = pages.find(name);
                    if (i == pages.end())
                        cout << "reference to non-existing page in line " 
                                << linesrc << " of \"" << pathsrc << "\".\n";
                    else {
                        write_out("<a href=\"", w & WHRES);
                        write_out("<span class=\"page\" onclick=\"page('", 
                                w & ~WHRES);
                        write_out(name, w);
                        write_out("\">", w & WHRES);
                        write_out("')\">", w & ~WHRES);
                        write_out(value.size() ? value : i->second.title, w);
                        write_out("</a>", w & WHRES);
                        write_out("</span>", w & ~WHRES);
                        }
                    inwht = false;
                    }
                }

            // Translate smart quotes.
            else if (c == '\'') {
                write_out(inwht ? "&lsquo;" : "&rsquo;", w);
                inwht = false;
                }
            else if (c == '"') {
                write_out(inwht ? "&ldquo;" : "&rdquo;", w);
                inwht = false;
                }

            // Copy all other characters verbatim.
            else {
                write_out(c, w);
                inwht = false;
                }
            }
        }
    }

/* decode_escape --------------------------------------------------------------
This reads a source character following a backslash, interprets it as an 
escape, and returns it as a string.                                          */

string decode_escape() {
    string  s;

    int c = getsrc();
    switch (c) {
    case ' ': s = "&nbsp;";   break;  // non-breaking space
    case '&': s = "&amp;";    break;  // ampersand
    case '+': s = "&plusmn;"; break;  // plus or minus
    case '-': s = "&ndash;";  break;  // n dash
    case '.': s = "&hellip;"; break;  // ellipsis
    case '<': s = "&lt;";     break;  // less than
    case '=': s = "&ne;";     break;  // not equal
    case '>': s = "&gt;";     break;  // greater than
    case 'b': s = "&bull;";   break;  // bullet
    case 'c': s = "&cent;";   break;  // cent
    case 'd': s = "&deg;";    break;  // degree
    case 'g': s = "&ge;";     break;  // greater or equal
    case 'l': s = "&le;";     break;  // less or equal
    case 'm': s = "&mdash;";  break;  // m dash
    case 'n': s = "<br>";     break;  // line break
    case 'o': s = "&ohm;";    break;  // Greek omega
    case 'u': s = "&mu;";     break;  // Greek mu
    default:
        if (c >= 0) {
            if (c < ' ' && c != '\n') {
                cout << "control character " << int(c) << " in line " 
                        << linesrc << " of \"" << pathsrc 
                        << "\" converted to blank.\n";
                c = ' ';
                }
            s += c;
            }
        }
    return s;
    }

/* dir_create -----------------------------------------------------------------
If p exists, it and all its contents are deleted. Then, p is created as an 
empty directory, including creating any non-existent ancestors. This aborts on 
any error.                                                                   */

void dir_create(path const& p) {
    error_code  err;

    remove_all(p, err);
    if (err) {
        cerr << "HELPCOMP -- can't clear directory \"" << p << "\".\n";
        exit(1);
        }
    create_directories(p, err);
    if (err) {
        cerr << "HELPCOMP -- can't create directory \"" << p << "\".\n";
        exit(1);
        }
    }

/* dir_within -----------------------------------------------------------------
This returns true if canonical pathname p1 and p2 are the same (without regard 
to the case of letters), or p1 is a parent of p2, or p2 is a parent of p1.   */

bool dir_within(path const& p1, path const& p2) {
    auto o = mismatch(p1.begin(), p1.end(), p2.begin(), p2.end(), nocase_eq());

    return o.first == p1.end() || o.second == p2.end();
    }

/* ends_with ------------------------------------------------------------------
This returns true if string s ends with e, without regard to case.           */

bool ends_with(string const& s, string_view e) {

    return s.size() > e.size() 
            && !_stricmp(s.data() + s.size() - e.size(), e.data());
    }

/* getsrc ---------------------------------------------------------------------
These return the next character or line from the datasrc string. The first 
returns -1 on EOF, the second returns false. Both count lines in linesrc. The 
second strips newlines, and doesn't return any partial line at the end.      */

int getsrc() {
    int     c;

    if (indexsrc >= datasrc.size())
        return -1;
    c = datasrc[indexsrc++];
    if (c == '\n')
        ++linesrc;
    return c;
    }

bool getsrc(string& s) {
    int     c;

    s.clear();
    while (indexsrc < datasrc.size()) {
        c = datasrc[indexsrc++];
        if (c == '\n') {
            ++linesrc;
            return true;
            }
        s += char(c);
        }
    return false;
    }

/* json_write -----------------------------------------------------------------
This writes a JSON file called name containing map m to both output 
directories.                                                                 */

void json_write(path const& name, mapstrstr const& m) {
    string      s;
    char        sep = '{';

    open_ofstream(ofshtml, pathhtml = dirhtml / name);
    open_ofstream(ofsres, pathres = dirres / name);
    for (auto const& ss: m) {
        s = sep;
        s += "\n\"";
        s += ss.first;
        s += "\":\"";
        s += ss.second;
        s += '"';
        write_out(s, WHHTML | WHRES);
        sep = ',';
        }
    write_out("\n}\n", WHHTML | WHRES);
    ofshtml.close();
    ofsres.close();
    }

/* mark_references ------------------------------------------------------------
This recursively marks referenced images, pages, and popups, starting with page 
or popup h. The value of b is one of the following:

    1 (REFORPHAN): h is a page or popup that can't be reached from contents.txt 
    without traversing at least 1 popup. 

    2 (REFPOPUP): h is a popup that can be reached from contents.txt without 
    traversing any popups.

    3 (REFPAGE): h is a page that can be reached from contents.txt without 
    traversing any popups.

If the references value for h is already at least b, this does nothing. 
Otherwise, it enlarges the references value to b and:

    It ensures the references value for all images referenced by h is at least 
    b.

    It recurses for all popups referenced by h, changing REFPOPUP to REFORPHAN, 
    or REFPAGE to REFPOPUP.

    It recurses for all pages referenced by h, changing REFPOPUP to 
    REFORPHAN.                                                               */

void mark_references(html& h, unsigned b) {

    if (h.references < b) {
        h.references = b;
        for (string const& s: h.images)
            images[s] = max(images[s], b);
        for (string const& s: h.popups)
            mark_references(popups[s], b == REFPOPUP ? REFORPHAN 
                    : b == REFPAGE ? REFPOPUP : b);
        for (string const& s: h.pages)
            mark_references(pages[s], b == REFPOPUP ? REFORPHAN : b);
        }
    }

/* nav_lookup -----------------------------------------------------------------
This looks up name n in map m, and returns the resulting name and title, or 
null strings if not listed.                                                  */

void nav_lookup(mapstrstr const& m, string const& n, string& name, 
        string& title) {

    auto i = m.find(n);
    if (i == m.end())
        name = title = string();
    else {
        name = i->second;
        title = titles[name];
        }
    }

/* open_ofstream --------------------------------------------------------------
This opens ofs to write s in binary mode (to suppress \r generation), and 
aborts on an error.                                                          */

void open_ofstream(ofstream& ofs, path const& s) {

    ofs.open(s, ios::binary);
    if (!ofs.is_open()) {
        cerr << "HELPCOMP -- error creating \"" << s << "\".\n";
        exit(1);
        }
    }

/* parse_name -----------------------------------------------------------------
This interprets string s as a line from "contents.txt" or "extras.txt" file, 
decomposes it into a name string and a title string, and returns the number of 
leading blanks. The name string must be letters, digits, underscores, or 
hyphens, but must not end with an underscore or have consecutive underscores. 
If it is followed by additional text separated by a blank, that is used as the 
title for the page, after stripping leading and trailing whitespace and 
converting other consecutive whitespace into single blanks. All control and 
non-ASCII characters are illegal, and cause this to return -1, as does any 
other error.                                                                 */

int parse_name(string const& s, string& name, string& title) {
    bool        f;      // flag
    char const* c;      // string scanner
    int         n;      // leading blank counter

    // Clear results.
    name.clear();
    title.clear();

    // Count leading blanks.
    c = s.c_str();
    n = 0;
    while (*c == ' ') {
        ++n;
        ++c;
        }

    // Must not be empty.
    if (!*c)
        return -1;

    // Copy valid characters into name.
    f = false;
    while (isalnum(*c) || *c == '_' || *c == '-' || *c == '.') {
        if (*c != '_')
            f = false;
        else if (f)
            return -1;
        else
            f = true;
        name += *c++;
        }

    // Must not be empty or end in an underscore.
    if (!name.size() || f)
        return -1;

    // If not at end of string or blank, error.
    if (*c && *c != ' ')
        return -1;

    // Skip whitespace. If any more characters...
    while (*c == ' ')
        ++c;
    if (*c) {

        // Copy title, coalescing blanks and stripping trailing blanks, 
        //  and converting special chars to entities.
        f = false;
        do {
            if (' ' > *c || *c > '~')
                return -1;
            else if (*c == ' ')
                f = true;
            else {
                if (f) {
                    title += ' ';
                    f = false;
                    }
                if (*c == '&')
                    title += "&amp;";
                else if (*c == '<')
                    title += "&lt;";
                else if (*c == '>')
                    title += "&gt;";
                else if (*c == '"')
                    title += "&dquot;";
                else
                    title += *c;
                }
            ++c;
            } while (*c);
        }

    // Return number of leading blanks.
    return n;
    }

/* process_contents -----------------------------------------------------------
This processes the source data as as the contents file. It adds each name and 
explicit title to the fileinfos map, adds each indentation level and name to 
the contents list, and adds items to the navnext, navprev, navup, and navdown 
maps that will be used to generate the JSON files that describe the contents 
navigation links.                                                            */

void process_contents() {
    int         bcnt;       // number of leading blanks in line
    list<int>   bcnts;      // number of leading blanks for each level
    string      lastpage;   // last page at current indentation level
    liststr     lastpages;  // last page at previous indentation levels
    string      line;       // line read from file
    string      name;       // parsed name
    string      title;      // parsed title

    // Start with "index" as last page.
    lastpage = "index";
    lastpages.push_back(lastpage);
    contents.push_back(make_pair(0, lastpage));

    // For each line...
    while (getsrc(line)) {

        // Decode and validate line.
        bcnt = parse_name(line, name, title);
        if (bcnt < 0 || name[0] == '_' || name == "index") {
            cout << "invalid line " << linesrc << " in \"" << pathsrc 
                    << "\".\n";
            continue;
            }

        // Warn if duplicate.
        if (navup.find(name) != navup.end()) {
            cout << "duplicate name \"" << name << " in line " << linesrc 
                    << " in \"" << pathsrc << "\".\n";
            continue;
            }

        // Warn if file doesn't exist.
        auto i = pages.find(name);
        if (i == pages.end()) {
            cout << "missing page in line " << linesrc << " in \"" 
                    << pathsrc << "\".\n";
            continue;
            }

        // Record title if specified.
        if (title.size())
            i->second.title = title;

        // If this is first line, record indentation as level 0.
        if (!bcnts.size()) {
            bcnts.push_back(bcnt);
            navdown[lastpage] = name;
            lastpage = name;
            }

        // If more indentation, record new indentation level.
        if (bcnt > bcnts.back()) {
            lastpages.push_back(lastpage);
            bcnts.push_back(bcnt);
            navup[name] = lastpage;
            navdown[lastpage] = name;
            lastpage = name;
            }
        else {

            // For each previous indentation...
            while (bcnt < bcnts.back()) {
                bcnts.pop_back();

                // Abort if indentation error.
                if (bcnt > bcnts.back() || !lastpages.size()) {
                    cerr << "HELPCOMP -- indentation error at line " << linesrc 
                            << " in \"" << pathsrc << "\".\n";
                    exit(2);
                    }

                // Get previous last page.
                lastpage = lastpages.back();
                lastpages.pop_back();
                }

            // Create links.
            navprev[name] = lastpage;
            navnext[lastpage] = name;
            if (lastpages.size())
                navup[name] = lastpages.back();
            lastpage = name;
            }

        // Add indentation level and name to contents.
        contents.push_back(make_pair(bcnts.size(), name));
        }
    if (!linesrc) {
        cerr << "HELPCOMP -- \"" << pathsrc << "\" is empty.\n";
        exit(2);
        }
    }

/* process_extras -------------------------------------------------------------
This processes the source data as the extras file. Each line must contain a 
page or popup name (without ".html") and a specific default title. If the file 
doesn't exist, this emits a warning. Otherwise, it records the title.        */

void process_extras() {
    string      line;       // line read from file
    string      name;       // parsed name
    string      title;      // parsed title

    // For each line...
    while (getsrc(line)) {

        // Decode and warn for invalid line.
        if (parse_name(line, name, title) < 0 || !title.size()) {
            cout << "invalid line " << linesrc << " in \"" << pathsrc 
                    << "\".\n";
            continue;
            }

        // Warn if not listed in pages or popups, otherwise record title.
        if (name[0] == '_') {
            auto i = popups.find(name);
            if (i == popups.end()) {
                cout << "missing popup in line " << linesrc << " in \"" 
                        << pathsrc << "\".\n";
                continue;
                }
            else
                i->second.title = title;
            }
        else {
            auto i = pages.find(name);
            if (i == pages.end()) {
                cout << "missing page in line " << linesrc << " in \"" 
                        << pathsrc << "\".\n";
                continue;
                }
            else
                i->second.title = title;
            }
        }
    }

/* process_page ---------------------------------------------------------------
This compiles the page file called name, represented by h. It writes the 
resource version to dirres/name, the HTML version dirhtml/name.html, and 
appends the HTML version to ofsmaster. Any file references to other pages, 
popups, or images are recorded in h.                                         */

void process_page(string const& name, html& h) {
    string      text;       // temporary

    // Create output files.
    pathhtml = dirhtml / name;
    pathhtml += ".html";
    open_ofstream(ofshtml, pathhtml);
    pathres = dirres / name;
    pathres += ".html";
    open_ofstream(ofsres, pathres);

    // Compile page-head.txt to HTML page output.
    pathsrc = dirsrc / "page-head.txt";
    select_source(pathsrc, page_head);
    compile_head_tail(name, WHHTML);

    // Write separator to master file, except on first page.
    if (name != "index") {
        text = "<div id=\"";
        text += name;
        text += "\" class=\"newpage\"></div>";
        write_out(text, WHMASTER);
        }

    // Compile HTML to all three files.
    pathsrc = dirsrc / name;
    pathsrc += ".html";
    select_source(pathsrc, read_text(pathsrc));
    compile_html(h, WHALL);

    // Compile page-tail.txt to HTML page output.
    pathsrc = dirsrc / "page-tail.txt";
    select_source(pathsrc, read_text(pathsrc));
    compile_head_tail(name, WHHTML);

    // Close output files.
    ofshtml.close();
    ofsres.close();
    }

/* process_popup --------------------------------------------------------------
This processes the popup file called name, represented by h.                 */

void process_popup(string const& name, html& h) {

    // Read source file into buffer.
    pathsrc = dirsrc / name;
    pathsrc += ".html";
    select_source(pathsrc, read_text(pathsrc));

    // Create output files.
    pathhtml = dirhtml / name;
    pathhtml += ".html";
    open_ofstream(ofshtml, pathhtml);
    pathres = dirres / name;
    pathres += ".html";
    open_ofstream(ofsres, pathres);

    // Compile HTML.
    compile_html(h, ~WHMASTER);

    // Close output files.
    ofshtml.close();
    ofsres.close();
    }

/* read_binary, read_text -----------------------------------------------------
These return the contents of the file called p as a string. The second strips 
\r characters. They abort on any errors.                                     */

string read_binary(path const& p) {

    ifstream ifs(p, ios::binary | ios::ate);
    unsigned n = unsigned(ifs.tellg());
    if (n >= 0x40000) {
        cerr << "HELPCOMP -- \"" << p << "\" is too big.\n";
        exit(2);
        }
    string s(n, '\0');
    ifs.seekg(0);
    if (!ifs.read(s.data(), n)) {
        cerr << "HELPCOMP -- error reading \"" << p << "\".\n";
        exit(1);
        }
    return s;
    }

string read_text(path const& p) {
    unsigned j = 0;
    string s = read_binary(p);

    for (unsigned i = 0; i < s.size(); ++i)
        if (s[i] != '\r')
            s[j++] = s[i];
    s.resize(j);
    return s;
    }

/* select_source --------------------------------------------------------------
This sets pathsrc to p, in srcdata to s, and resets the line counter and 
index.                                                                       */

void select_source(path const& p, string const& s) {

    indexsrc = 0;
    linesrc = 1;
    pathsrc = p;
    datasrc = s;
    }

/* valid_name -----------------------------------------------------------------
This returns true if name isn't empty and contains only letters, digits, 
underscores, or hyphens, and doesn't end in an underscore or contain 
consecutive underscores.                                                     */

bool valid_name(string const& name) {
    bool    u = false;

    if (!name.size())
        return false;
    for (char c: name) {
        if (c == '_') {
            if (u)
                return false;
            else
                u = true;
            }
        else if (!isalnum(c) && c != '-')
            return false;
        else
            u = false;
        }
    return !u;
    }

/* write_binary ---------------------------------------------------------------
This writes string s to the file called p, overwriting it if it already exists. 
It aborts on any error.                                                      */

void write_binary(path const& p, string const& s) {

    ofstream ofs(p, ios::binary | ios::ate);
    if (!ofs.is_open()) {
        cerr << "HELPCOMP -- can't create \"" << p << "\".\n";
        exit(1);
        }
    ofs.write(s.data(), s.size());
    if (!ofs) {
        cerr << "HELPCOMP -- error writing \"" << p << "\".\n";
        exit(1);
        }
    }

/* write_one ------------------------------------------------------------------
These write to output file stream o whose path is p, and aborts on any error.*/

void write_one(ofstream& o, path const& p, char c) {

    o.put(c);
    if (!o) {
        cerr << "HELPCOMP -- error writing \"" << p << "\".\n";
        exit(1);
        }
    }

void write_one(ofstream& o, path const& p, string const& s) {

    o.write(s.data(), s.size());
    if (!o) {
        cerr << "HELPCOMP -- error writing \"" << p << "\".\n";
        exit(1);
        }
    }

void write_one(ofstream& o, path const& p, char const* s) {

    o.write(s, strlen(s));
    if (!o) {
        cerr << "HELPCOMP -- error writing \"" << p << "\".\n";
        exit(1);
        }
    }

/* write_out ------------------------------------------------------------------
These write to the output files selected by w, and aborts on any error.      */

void write_out(char c, uint8_t w) {

    if (w & WHHTML)
        write_one(ofshtml, pathhtml, c);
    if (w & WHMASTER)
        write_one(ofsmaster, pathmaster, c);
    if (w & WHRES)
        write_one(ofsres, pathres, c);
    }

void write_out(string const& s, uint8_t w) {

    if (w & WHHTML)
        write_one(ofshtml, pathhtml, s);
    if (w & WHMASTER)
        write_one(ofsmaster, pathmaster, s);
    if (w & WHRES)
        write_one(ofsres, pathres, s);
    }

void write_out(const char* s, uint8_t w) {

    if (w & WHHTML)
        write_one(ofshtml, pathhtml, s);
    if (w & WHMASTER)
        write_one(ofsmaster, pathmaster, s);
    if (w & WHRES)
        write_one(ofsres, pathres, s);
    }

/* write_qrc ------------------------------------------------------------------
This writes an entry for the resource called n to the QRC output. If x isn't 
t empty, this adds x to the file pathname, but not to the resource name.     */

void write_qrc(string const& n, char const* x) {
 
    if (x) {
        write_one(ofsqrc, pathqrc, "        <file alias=\"");
        write_one(ofsqrc, pathqrc, n);
        write_one(ofsqrc, pathqrc, "\">");
        write_one(ofsqrc, pathqrc, n);
        write_one(ofsqrc, pathqrc, x);
        }
    else {
        write_one(ofsqrc, pathqrc, "        <file>");
        write_one(ofsqrc, pathqrc, n);
        }
    write_one(ofsqrc, pathqrc, "</file>\n");
    }

// Main program ---------------------------------------------------------------

int main(int argc, char const* const* argv) {
    error_code  err;            // file system error code
    path        dirhtml_c;      // dirhtml in canonical form
    path        dirres_c;       // dirres in canonical form
    path        dirsrc_c;       // dirsrc in canonical form
    unsigned    missing = 0xFF; // bitmask indicating missing files
    string      name;           // filename portion of pname
    ofstream    ofs;            // output file stream
    path        pname;          // pathname

    if (argc != 4 || argv[1][0] == '/') {
        cerr << "HELPCOMP -- DIGITAL CHROMA TOOLKIT HELP COMPILER\n\nHELPCOMP "
                "dirsrc dirres dirhtml\n\ndirsrc      the source input directo"
                "ry\ndirres      the resource output directory\ndirhtml     th"
                "e HTML output directory\n";
        return 3;
        }

    // Record three canonicalized pathnames, make sure the first one exists.
    dirsrc_c = canonical(dirsrc = argv[1], err);
    if (err || !exists(dirsrc_c)) {
        cerr << "HELPCOMP -- can't find \"" << dirsrc << "\".\n";
        return 1;
        }
    dirres_c = canonical(dirres = argv[2], err);
    if (err) {
        cerr << "HELPCOMP -- error checking \"" << dirres << "\".\n";
        return 1;
        }
    dirhtml_c = canonical(dirhtml = argv[3], err);
    if (err) {
        cerr << "HELPCOMP -- error checking \"" << dirhtml << "\".\n";
        return 1;
        }

    // Make sure directories aren't within each other.
    if (dir_within(dirsrc_c, dirres_c) || dir_within(dirsrc_c, dirhtml_c)
            || dir_within(dirres_c, dirhtml_c)) {
        cerr << "HELPCOMP -- dirsrc, dirres, and dirhtml "
                "must not be within each other.\n";
        return 2;
        }

    // For each file in source directory...
    for (auto& dent: directory_iterator(dirsrc, err)) {

        // Skip non-files with warnings.
        pname = dent.path();
        if (dent.status(err).type() != file_type::regular) {
            cout << "\"" << pname << "\" is not a regular file.\n";
            continue;
            }

        // Extract filename and extensions.
        name = pname.filename().u8string();

        // If HTML file encountered...
        if (ends_with(name, ".html"sv)) {

            // Reject invalid names, and "master".
            name.resize(name.size() - 5);
            if (name == "master" || !valid_name(name)) {
                cout << "\"" << pname 
                        << "\" is not a valid page or popup name.\n";
                continue;
                }

            // Add to popups or pages list with auto-generated title.
            if (name[0] == '_')
                popups[name] = html(name);
            else {
                pages[name] = html(name);

                // Record when "index.html" found, change title to "Home".
                if (name == "index") {
                    missing &= ~0x10;
                    pages[name].title = "Home";
                    }
                }
            }

        // If image, stylesheet, or script, record its existence.
        else if (ends_with(name, ".png"sv) || ends_with(name, ".jpg"sv))
            images[name] = 0;
        else  if (ends_with(name, ".css"sv)) {
            stylesheets[name] = 0;
            if (name == "styles.css")
                missing &= ~0x20;
            }
        else if (ends_with(name, ".js"sv))
            scripts[name] = 0;

        // If head/tail fragment, read it into a string if for pages.
        else if (name == "master-head.txt")
            missing &= ~1;
        else if (name == "master-tail.txt")
            missing &= ~2;
        else if (name == "page-head.txt") {
            page_head = read_text(pname);
            missing &= ~4;
            }
        else if (name == "page-tail.txt") {
            page_tail = read_text(pname);
            missing &= ~8;
            }

        // If "contents.txt" or "extras.txt" encountered, record presence.
        else if (name == "contents.txt")
            missing &= ~0x40;

        // If "extras.txt" encountered, read and process it.
        else if (name == "extras.txt")
            missing &= ~0x80;

        // Skip and warn about anything else.
        else
            cout << "\"" << pname << "\" is unknown type.\n";
        }
    if (err) {
        cerr << "HELPCOMP -- error reading \"" << dirsrc << "\".\n";
        return 1;
        }

    // Abort if required files not found.
    if (missing & 1)
        cout << "no \"master_head.txt\" file found.\n";
    if (missing & 2)
        cout << "no \"master_tail.txt\" file found.\n";
    if (missing & 4)
        cout << "no \"page_head.txt\" file found.\n";
    if (missing & 8)
        cout << "no \"page_tail.txt\" file found.\n";
    if (missing & 0x10)
        cout << "no \"index.html\" file found.\n";
    if (missing & 0x20)
        cout << "no \"styles.css\" file found.\n";
    if (missing & 0x40)
        cout << "no \"contents.txt\" file found.\n";
    if (missing & 0x7F) {
        cerr << "HELPCOMP -- required file(s) missing.\n";
        return 2;
        }

    // Process contents.txt.
    pathsrc = dirsrc / "contents.txt";
    select_source(pathsrc, read_text(pathsrc));
    process_contents();

    // Process extras.txt if it exists.
    if (!(missing & 0x80)) {
        pathsrc = dirsrc / "extras.txt";
        select_source(pathsrc, read_text(pathsrc));
        process_extras();
        }

    // Copy titles into a separate map.
    for (auto const& p: pages)
        titles[p.first] = p.second.title;

    // Create or clear output directories.
    dir_create(dirres);
    dir_create(dirhtml);

    // Create "master.html".
    pathmaster = dirhtml / "master.html";
    open_ofstream(ofsmaster, pathmaster);

    // Compile head to it.
    pathsrc = dirsrc / "master-head.txt";
    select_source(pathsrc, read_text(pathsrc));
    compile_head_tail(string(), WHMASTER);

    // Process all existing page files referenced in contents.txt.
    for (auto const& ci: contents) {
        pages[ci.second].references = REFPAGE; // reset in next step
        process_page(ci.second, pages[ci.second]);
        }

    // Process all existing page files not referenced in contents.txt.
    for (auto& p: pages)
        if (p.second.references)
            p.second.references = REFNONE; // set in previous step
        else
            process_page(p.first, p.second);

    // Compile tail to "master.html", close it.
    pathsrc = dirsrc / "master-tail.txt";
    select_source(pathsrc, read_text(pathsrc));
    compile_head_tail(string(), WHMASTER);
    ofsmaster.close();

    // Process all existing popup files.
    for (auto& p: popups)
        process_popup(p.first, p.second);

    // Mark all files accessible from contents.
    for (auto const& ci: contents)
        mark_references(pages[ci.second], REFPAGE);

    // Write beginning of "help.qrc".
    pathqrc = dirres / "help.qrc";
    open_ofstream(ofsqrc, pathqrc);
    write_one(ofsqrc, pathqrc, 
            "<!DOCTYPE RCC>\n<RCC>\n    <qresource prefix=\"/help\">\n");

    // Add all referenced pages to "help.qrc", warn for unreferenced ones, 
    //  warn for ones only accessible via a popup.
    for (auto const& p: pages) {
        name = p.first;
        if (p.second.references == REFNONE)
            cout << "no reference to page \"" << name << "\".\n";
        else {
            if (p.second.references == REFORPHAN)
                cout << "page \"" << name << "\" only referenced via popup.\n";
            write_qrc(name, ".html");
            }
        }

    // Add all referenced popups to "help.qrc", warn for unreferenced ones, 
    //  warn for ones only accessible via other popup.
    for (auto const& p: popups) {
        name = p.first;
        if (p.second.references == REFNONE)
            cout << "no reference to popup \"" << name << "\".\n";
        else {
            if (p.second.references == REFORPHAN)
                cout << "popup \"" << name 
                        << "\" only referenced via another popup.\n";
            write_qrc(name, ".html");
            }
        }

    // Copy all referenced images to both directories and add to "help.qrc", 
    //  warn for unreferenced ones, 
    //  warn for ones only accessible indirectly via popup.
    for (auto const& i: images) {
        name = i.first;
        if (i.second == REFNONE)
            cout << "no reference to image \"" << name << "\".\n";
        else {
            if (i.second == REFORPHAN)
                cout << "image \"" << name 
                        << "\" only referenced via popup.\n";
            string s = read_binary(dirsrc / name);
            write_binary(dirres / name, s);
            write_binary(dirhtml / name, s);
            write_qrc(name, nullptr);
            }
        }

    // Write styles.css to resource directory, add to "help.qrc".
    pname = dirres / "styles.css";
    open_ofstream(ofs, pname);
    write_one(ofs, pname, read_text(dirsrc / "styles.css"));
    ofs.close();
    write_qrc("styles.css", nullptr);

    // Write JSON navigation files to dirres and htmlres, add to "help.qrc".
    json_write("next.json", navnext);
    json_write("prev.json", navprev);
    json_write("up.json", navup);
    json_write("down.json", navdown);
    json_write("titles.json", titles);
    write_qrc("next.json", nullptr);
    write_qrc("prev.json", nullptr);
    write_qrc("titles.json", nullptr);
    write_qrc("up.json", nullptr);
    write_qrc("down.json", nullptr);

    // Write end of "help.qrc".
    write_one(ofsqrc, pathqrc, "    </qresource>\n</RCC>\n");
    ofsqrc.close();

    // Write scripts and stylesheets to HTML directory, warn if unreferenced.
    for (auto const& s: scripts) {
        name = s.first;
        if (!s.second)
            cout << "no reference to script \"" << name << "\".\n";
        else {
            pname = dirhtml / name;
            open_ofstream(ofs, pname);
            write_one(ofs, pname, read_text(dirsrc / name));
            ofs.close();
            }
        }
    for (auto const& s: stylesheets) {
        name = s.first;
        if (!s.second)
            cout << "no reference to stylesheet \"" << name << "\".\n";
        else {
            pname = dirhtml / name;
            open_ofstream(ofs, pname);
            write_one(ofs, pname, read_text(dirsrc / name));
            ofs.close();
            }
        }

    return 0;
    }
